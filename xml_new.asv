function [new_climate_file] = xml_new(CL_EPW_PATH,CL_EPW,CL_XML_PATH,CL_XML,CL_RE_PATH,CL_RE)
    % =========================================================================
    %  THE URBAN WEATHER GENERATOR
    % =========================================================================
    % Orig. Author: B. Bueno & edited by A. Nakano & Lingfu Zhang
    % Last modified by Joseph Yang (joeyang@mit.edu)
    % latest modification 2016-01-26
    % Changes
    % 1. Minor typo fixed ('Wa11' to 'Wall')
    % 2. Shortened code and added a section to break up single material
    % 3. Re-added section to break up thick layers (>5cm)
    % 4. Consolidated sections of the code to generate Element class
    %    and added sectin to read from XML or matlab file (.m or .mat)
    % 5. Soil temperature data also read in. A soil layer is added to the 
    %    bottom of the road (both rural/urban), which will then be fixed to
    %    the specified temperature per EPW. Forcing function changed to
    %    reflect this.
    % 6. Max/min layer thickness is now defined - default is 5cm, 1cm
    % 7. Combined both XML version & Matlab input versions
    % 8. Physical constant definitions added to the main section of the
    %    script and updated Param.m 
    % 
    % 
    % Notes
    % a. When compiling, add 'coolCap.txt' and 'z_meso.txt' to list of files
    % =========================================================================
    %
    % Program description can be found in the following papers:
    %  - Aiko's Master Thesis (2014)
    %   Bueno's paper
    % http://hydrashare.github.io/hydra/
    % http://urbanmicroclimate.scripts.mit.edu/
    % https://github.com/hansukyang/UWG_Matlab

    % =========================================================================
    % Program interface
    % =========================================================================
    % Input files
    % .epw: main weather file used 
    % .xml: typology definition 
    % Output files
    % .epw file: main weather with urban canyon temperature
    % .mat file: program dump of last run
    % .log file: summary of the simulation run

    % =========================================================================
    % Program Workflow (xml)
    % =========================================================================
    % 1. Select epw file for rural station
    % 2. Select xml file that defines urban area (can be auto-generated by
    %   grasshopper - see http://hydrashare.github.io/hydra/)
    % 3. Run UWG
    
    % =========================================================================    
    % Main classes used
    % =========================================================================
    % SimParam -> collection of simulation parameters
    % Weather.m -> class for holding rural weather patterns
    % Param.m -> define other simulation parameters
    % Element.m -> define roof, wall, road, mass based on materials
    % Building -> collection of roof, wall, mass elements
    % ReferenceSite -> define the rural landscape

    % =========================================================================    
    % Main functions called
    % =========================================================================    
    % procMat.m -> processes data read from xml before calling Element.m
    % 
    % =========================================================================
    % Program limitations
    % =========================================================================
    % 1. Note the height of the urban canyon temperature, which is not
    %   necessarily the inlet air temperature (to be discussed with Les)
    % 2. The program is designed for fast computation, and uses fixed
    %   simulation step size. Although this can be adjusted, if a thermal
    %   layer is very thin, the program will crash. (min thickess = 1cm)
    % 3. The ground sink temperature (average of the air temperature) is
    %   set to the last (bottom) road layer. For XML files, the road
    %   elements are bufferred with layer thickness of 5cm.
    % 4. See Bruno's paper for other limitations
    % 

    % =========================================================================
    % Section 1 - Definitions for constants / other parameters
    % =========================================================================
    sim_dt = 60;            % Simulation time step (s)
    weather_dt = 3600;      % Weather data time step (EPW) (s)
    fullyScripted = 1;
    autosize = 0;           % HAVC autosizing
    min_thickness = 0.01;   % Minimum layer thickness (to prevent crashing)
    max_thickness = 0.05;   % Maximum layer thickness (5cm - discussed with L. Norford)
    soilTcond = 1;          % http://web.mit.edu/parmstr/Public/NRCan/nrcc29118.pdf (Figly & Snodgrass)
    soilvolHeat = 2e6;      % http://www.europment.org/library/2013/venice/bypaper/MFHEEF/MFHEEF-21.pdf (average taken from Table 1)
    soil = Material(soilTcond,soilvolHeat); % Soil material used for soil-depth padding

    % Physical parameters
    g = 9.81;               % gravity
    cp = 1004.;             % heat capacity for air (constant pressure)
    vk = 0.40;              % von karman constant
    r = 287.;               % gas constant
    rv = 461.5;             %
    lv = 2.26e6;            % latent heat of evaporation
    sigma = 5.67e-08 ;      % Stefan Boltzmann constant
    waterDens = 1000;       % water density (kg/m^3)
    lvtt = 2.5008e6;        %
    tt = 273.16;            %
    estt = 611.14;          %
    cl = 4.218e3;           %
    cpv = 1846.1;           %
    b = 9.4;                % Coefficients derived by Louis (1979)
    cm = 7.4;               %
    colburn = (0.713/0.621)^(2./3.); % (Pr/Sc)^(2/3) for Colburn analogy in water evaporation
    
    % Site-specific parameters    
    windMin = 0.1;          % minimum wind speed (m s-1)
    windMax = 10;           % maximum wind speed (m s-1)
    wgmax = 0.005;          % maximum film water depth on horizontal surfaces (m)
    exCoeff = 0.3;          % exchange velocity coefficient
    maxdx = 500;            % maximum discretization length for the UBL model (m)
    circCoeff = 1.2;        %
    dayThreshold = 200;     %
    nightThreshold = 50;    %

    % =========================================================================
    % Section 2 - Read EPW file
    % =========================================================================
    try
        climate_data = strcat(CL_EPW_PATH,'\',CL_EPW);
        epwPathName = CL_EPW_PATH;
        epwFileName = CL_EPW;
        [pathstr,name,ext] = fileparts(climate_data);
        epwFileExt = ext;
    catch
        [epwFileName,epwPathName] = uigetfile('.epw','Select Rural EnergyPlus Weather File');
        climate_data = strcat(epwPathName,epwFileName);
        epwPathName = epwPathName(1:end-1);
    end

    disp(['Rural weather file selected: ',climate_data])
    epwid = fopen(climate_data);
    C = importdata(climate_data, ',', 8);
    
    % Read header lines (1 to 8) from EPW and ensure TMY2 format
    % Note that TMY3 format is not compatible with the current version of UWG
    header = C.textdata(1:8,1);
    TMY2 = strfind(header(1), 'TMY2');
    if isempty(TMY2{1})
        disp('UWG unable to run: UWG requires TMY2 format for weather data');
        new_climate_file = 0;
        return;
    end
    
    % Read in soil temperature data from line 4 of EPW file
    soildata = strsplit(header{4},',');
    n_soil = str2num(soildata{2});
    Tsoil = zeros(n_soil,12);
    depth = zeros(n_soil,1);
    
    % Read monthly data for each layer of soil from EPW file
    for i = 1:n_soil
        depth(i) = str2num(soildata{3 + (i-1)*13});
        % Monthly data
        for j = 1:12 
            Tsoil(i,j) = str2num(soildata{3+(i-1)*13+j})+273.15;
        end
    end

    % Read weather data from EPW for each time step in weather file
    i = 1;
    readin = fgetl(epwid);
    while (readin ~= -1)
        epwinput.values(i,:) = textscan(readin, '%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %*[^\n]', 'delimiter',',','MultipleDelimsAsOne',1);
        i=i+1;
        readin = fgetl(epwid);
    end
    epwinput.values(1:8,:) = []; % Ignore the header lines (first 8)
    fclose all;

    % Save location for the new EPW file
    try
        new_climate_file = strcat(CL_RE_PATH,'\',CL_RE);
        newPathName = CL_RE_PATH;
        newFileName_withExt = CL_RE;    
    catch
        [newFileName_withExt,newPathName] = uiputfile('.epw','Select save location');
        new_climate_file = strcat(newPathName,newFileName_withExt);    
        newPathName = newPathName(1:end-1);
    end

    [~,newFileName,~] = fileparts(new_climate_file);
    disp(['Save location selected: ',new_climate_file]);
    
    % =========================================================================
    % Section 3 - Read Input File (XML, .m or .mat file)
    % =========================================================================
    
    try
        xml_location = strcat(CL_XML_PATH,'\',CL_XML);
    catch
        [FileName,PathName] = uigetfile('*.xml;*.m;*.mat','Select Urban Parameter Input file');
        xml_location = strcat(PathName,FileName);
    end
    [~,~,ext] = fileparts(xml_location);
    
    % Three input files for UWG - note that soil layer buffering and 
    % layer thickness control are only performed for XML. For .m and .mat,
    % the program assumes they've been correctly generated.
    if strcmp(ext,'.m')
        % Run matlab script to generate urbanArea, ulbVars, etc.
        run(xml_location);
    elseif strcmp(ext,'.mat')
        % Read urbanArea, ulbVars from .mat file
        load(xml_location);
    else
        % Process XML file to generate urbanArea, ulbVars
        xml_input = xml_read(xml_location);
        disp(['Urban Parameter file selected: ',xml_location]);

        % Re-naming for file readability
        xmlTyp(1) = xml_input.typology1;
        xmlTyp(2) = xml_input.typology2;
        xmlTyp(3) = xml_input.typology3;
        xmlTyp(4) = xml_input.typology4;
        building(1) = xmlTyp(1).building;
        building(2) = xmlTyp(2).building;
        building(3) = xmlTyp(3).building;
        building(4) = xmlTyp(4).building;
        xmlParam = xml_input.parameter;
        xmlUArea = xml_input.urbanArea;
        xmlRSite = xml_input.referenceSite;

        % Simulation paramters
        simParam = SimParam(sim_dt,weather_dt,xmlParam.simuStartMonth,...
            xmlParam.simuStartDay, xmlParam.simuDuration);
        weather = Weather(climate_data,simParam.timeInitial,simParam.timeFinal);
        nightStart = mean([building.nightSetStart]);
        nightEnd = mean([building.nightSetEnd]);
        geoParam = Param(xmlUArea.daytimeBLHeight,xmlUArea.nighttimeBLHeight,...
            xmlUArea.refHeight,xmlParam.tempHeight,xmlParam.windHeight,...
            circCoeff,dayThreshold,nightThreshold,xmlUArea.treeLatent,xmlUArea.grassLatent,xmlUArea.vegAlbedo,...
            xml_input.urbanArea.vegStart,xml_input.urbanArea.vegEnd,...
            nightStart,nightEnd,windMin,windMax,wgmax,exCoeff,maxdx,...
            g, cp, vk, r, rv, lv, pi(), sigma, waterDens, lvtt, tt, estt, cl, cpv, b, cm, colburn);

        % Define Road Element 
        urbanRoad = xmlUArea.urbanRoad;
        [roadMat, newthickness] = procMat(urbanRoad.materials,max_thickness,min_thickness);

        % Buffer road element with additional soil layers
        for i = 1:n_soil
            if sum(newthickness) <= depth(i)
                while(sum(newthickness)<depth(i))
                    newthickness = [newthickness; max_thickness];
                    roadMat = [roadMat soil];
                end
                soilindex1 = i;
                break;
            end
        end
        road = Element(urbanRoad.albedo,urbanRoad.emissivity,newthickness,roadMat,...
            urbanRoad.vegetationCoverage,urbanRoad.initialTemperature + 273.15,urbanRoad.inclination);

        % Define Rural Element
        ruralRoad = xmlRSite.ruralRoad;
        [ruralMat, newthickness] = procMat(ruralRoad.materials,max_thickness,min_thickness);

        % Buffer road element with additional soil layers to use soil
        % temperature data
        for i = 1:n_soil
            if sum(newthickness) <= depth(i)
                while(sum(newthickness)<depth(i))
                    newthickness = [newthickness; max_thickness];
                    ruralMat = [ruralMat soil];
                end
                soilindex2 = i;
                break;
            end
        end
        rural = Element(ruralRoad.albedo,ruralRoad.emissivity,newthickness,...
            ruralMat,ruralRoad.vegetationCoverage,ruralRoad.initialTemperature + 273.15,ruralRoad.inclination);

        for i = 1:4
            % Define Wall element
            [wallMat, newthickness] = procMat(xmlTyp(i).construction.wall.materials,max_thickness,min_thickness);
            xwall = xmlTyp(i).construction.wall;
            wall(i) = Element(xwall.albedo,xwall.emissivity,newthickness,wallMat,...
                xwall.vegetationCoverage,xwall.initialTemperature + 273.15,xwall.inclination);

            % Define Roof element
            [roofMat, newthickness] = procMat(xmlTyp(i).construction.roof.materials,max_thickness,min_thickness);
            xroof = xmlTyp(i).construction.roof;
            roof(i) = Element(xroof.albedo,xroof.emissivity,newthickness,roofMat,...
                xroof.vegetationCoverage,xroof.initialTemperature + 273.15,xroof.inclination);

            % Define Mass element
            [massMat, newthickness] = procMat(xmlTyp(i).construction.mass.materials,max_thickness,min_thickness);
            xmass = xmlTyp(i).construction.mass;
            mass(i) = Element(xmass.albedo,xmass.emissivity,newthickness,massMat,...
                xmass.vegetationCoverage,xmass.initialTemperature + 273.15,xmass.inclination);

            % Define building typology
            typology(i) = Building(building(i).floorHeight,...
                building(i).nightInternalGains,...
                building(i).dayInternalGains,...
                building(i).radiantFraction,...
                building(i).latentFraction,...
                building(i).infiltration,...
                building(i).ventilation,...
                xmlTyp(i).construction.glazing.glazingRatio,...
                xmlTyp(i).construction.glazing.windowUvalue,...
                xmlTyp(i).construction.glazing.windowSHGC,...
                building(i).coolingSystemType,...
                building(i).coolingCOP,...
                building(i).heatReleasedToCanyon,...
                building(i).daytimeCoolingSetPoint + 273.15,...
                building(i).nighttimeCoolingSetPoint + 273.15,...
                building(i).daytimeHeatingSetPoint + 273.15,...
                building(i).nighttimeHeatingSetPoint + 273.15,...
                building(i).coolingCapacity,...
                building(i).heatingEfficiency,...
                building(i).initialT + 273.15);

            % Define Urban Configuration [building,mass,wall,roof,road]
            urbanConf(i) = UrbanConf(typology(i),mass(i),wall(i),roof(i),road);
            CityBlock (i) = Block(xmlParam.simuDuration * 24,wall(i),roof(i),mass(i),road);
        end 

        % Reference site class
        refSite = ReferenceSite(xmlRSite.latitude,xmlRSite.longitude,xmlRSite.averageObstacleHeight,...
            weather.staTemp(1),weather.staPres(1),geoParam);

        % Urban Usage [Fraction of urban configurations,urban configurations]
        typDist = [xmlTyp(1).dist xmlTyp(2).dist xmlTyp(3).dist xmlTyp(4).dist]/100;
        urbanUsage = UrbanUsage(typDist,[urbanConf(1), urbanConf(2), urbanConf(3), urbanConf(4)]);   

        % Define dominant typology
        [~,I] = max(typDist);
        dominantTypology = typology(I);
        dominantWall = wall(I);
        disp(dominantTypology);

        % Build definition of urbanArea class
        urbanArea = UrbanArea(xmlUArea.averageBuildingHeight,xmlUArea.siteCoverageRatio,... 
            xmlUArea.facadeToSiteRatio,xmlUArea.treeCoverage, xmlUArea.nonBldgSensibleHeat,...               
            xmlUArea.nonBldgLatentAnthropogenicHeat,weather.staTemp(1),weather.staHum(1),...
            weather.staUmod(1),geoParam,dominantTypology,dominantWall,road,rural); 
        ublVars = UblVars('C',xml_input.urbanArea.charLength,weather.staTemp(1),geoParam.maxdx); 
    end  

    % =========================================================================
    % Section 6 - HVAC Autosizing (if needed)
    % =========================================================================
    Fc = fopen('coolCap.txt','r+');
    for i = 1:numel(urbanArea)
        for j = 1:numel(urbanUsage(i).urbanConf)
            if autosize
                coolCap = Autosize(urbanArea(i),ublVars(i),...
                    urbanUsage(i).urbanConf(j),climate_data,rural,refSite,geoParam);
                fprintf(Fc,'%1.3f\n',coolCap);
                urbanUsage(i).urbanConf(j).building.coolCap = coolCap;
            else
                urbanUsage(i).urbanConf(j).building.coolCap = fscanf(Fc,'%f\n',1);
            end
        end
    end
    fclose(Fc);

    % =========================================================================
    % Section 7 - UWG main section
    % =========================================================================
    forc = Forcing(weather.staTemp);
    sensHeat = zeros(numel(urbanArea),1);

    % Data dump variables
    timeCount = 0.;
    index = 0;          
    Can_Tdb = [];       % Canyon temperature
    Can_hum = [];       % Canyon humidty
    dataSet = [];       % For datadump
    urbAreaData = [];
    ublVarData = [];
    WeatherData = [];
    time = [];
    
    for it=1:simParam.nt
        
        timeCount=timeCount+simParam.dt;
        simParam = UpdateDate(simParam);
        
        % Update soil deep temperature (from monthly EPW data)
        forc.deepTemp = Tsoil(soilindex1,simParam.month);
        
        % print file
        if eq(mod(timeCount,simParam.timePrint),0)
            for i = 1:numel(urbanArea)
                Can_Tdb = [Can_Tdb (urbanArea(i).canTemp) - 273.15];
                Can_hum = [Can_hum urbanArea(i).canHum];
                radTemp = [urbanUsage(1).urbanConf(1).wall.layerTemp(1) forc.skyTemp urbanUsage(1).urbanConf(1).road.layerTemp(1)];
                radTemp_calc = [radTemp, urbanArea(1).bldHeight urbanArea(1).canWidth];
                filename = strcat(newPathName,'\','Trad_',newFileName,'.csv');
                dlmwrite(filename,radTemp_calc,'delimiter',',','-append');
            end 
            % Update variables for data dump
            WeatherData = [WeatherData; forc];
            time = [time timeCount];
            ublVarData = [ublVarData ublVars];
            urbAreaData = [urbAreaData urbanArea];

            index = index + 1;
            for i = 1:numel(urbanUsage)
                % for each sub-area in the block
                for j = 1:numel(urbanUsage(i).urbanConf)
                    CityBlock(i,j) = UpdateStrct(CityBlock(i,j), urbanUsage(i).urbanConf(j),timeCount,index);
                    CityBlock(i,j) = UpdateArea(CityBlock(i,j), urbanArea(i),ublVars(i),index);
                end
            end
        end

        % Read forcing
        if eq(mod(timeCount,simParam.timeForcing),0) || eq(timeCount,simParam.dt)
            if le(forc.itfor,simParam.timeMax/simParam.timeForcing)
                forc = ReadForcing(forc,weather,geoParam);
                % Solar calculations
                [rural,urbanArea,urbanUsage] = SolarCalcs(urbanArea,urbanUsage,...
                  simParam,refSite,forc,geoParam,rural);
                [first,second,third] = PriorityIndex(forc.uDir,ublVars);
            end
        end
        
        % Rural heat fluxes
        rural.infra = forc.infra-sigma*rural.layerTemp(1)^4.;
        rural = SurfFlux(rural,forc,geoParam,simParam,forc.hum,forc.temp,forc.wind,2,0.);
        
        % Vertical profiles of meteorological variables at the rural site
        refSite = VerticalDifussionModel(refSite,forc,rural,geoParam,simParam );
        for i = 1:numel(urbanArea)
            % urban heat fluxes
            [urbanArea(i),ublVars(i),urbanUsage(i),forc] = UrbFlux(urbanArea(i),ublVars(i),...
            urbanUsage(i),forc,geoParam,simParam,refSite);
            % urban canyon temperature and humidity
            urbanArea(i) = UrbThermal(urbanArea(i),ublVars(i).ublTemp,urbanUsage(i),forc,geoParam,simParam);
        end
        
        % Urban boundary layer temperature
        for i=1:numel(urbanArea)
            sensHeat(i) = urbanArea(i).sensHeat;
        end
        ublVars = UrbanBoundaryLayerModel(ublVars,sensHeat,refSite,rural,forc,...
            geoParam,simParam,first,second,third);
        
        % Print progress
        if eq(mod(timeCount,3600.*24),0)
          progressbar(timeCount/(3600.*24)/365);
        end
    end

    % =========================================================================
    % Section 8 - Writing new EPW file
    % =========================================================================
    disp('Calculating new Temperature and humidity values')
    for iJ = 1:size(Can_Tdb,2)
        epwinput.values{iJ+simParam.timeInitial,7}{1,1} = num2str(Can_Tdb(iJ),'%0.1f'); % dry bulb temperature  [°C]
        [~, ~, Can_phi(iJ), ~, Can_Tdp(iJ), ~] = Psychrometrics(Can_Tdb(iJ), Can_hum(iJ), str2num(epwinput.values{iJ,10}{1,1}));
        epwinput.values{iJ+simParam.timeInitial,8}{1,1} = num2str(Can_Tdp(iJ),'%0.1f'); % dew point temperature [°C]
        epwinput.values{iJ+simParam.timeInitial,9}{1,1} = num2str(Can_phi(iJ),'%0.0f'); % relative humidity     [%]
    end
    progressbar(360/365);
    disp('writing new EPW file');

    % Writing new EPW file
    new_climate_file = strcat(newPathName,'\',newFileName,'.epw');
    epwnewid = fopen(new_climate_file,'w');
    for i = 1:8
        fprintf(epwnewid,'%s\r\n',header{i});
    end
    for i = 1:size(epwinput.values,1)
        printme = [];
        for e = 1:34
            printme = [printme epwinput.values{i,e}{1,1} ','];
        end
        printme = [printme epwinput.values{i,e}{1,1}];
        fprintf(epwnewid,'%s\r\n',printme);
    end

    progressbar(1);
    if fullyScripted
        disp('Inputs scripted, supressing pop-up notification...');
    else
        h = msgbox('Urban Weather Generation Complete','UWG 3.0','help');
    end
    disp(['New climate file generated: ',new_climate_file]);

    save ('UWGdump.mat','dataSet','refSite','urbanUsage','urbAreaData','ublVarData','WeatherData','Can_Tdb','Can_hum','CityBlock','time','Can_Tdp','Can_phi');
    fclose all;
end